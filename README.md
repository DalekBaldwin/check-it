![](http://www.textfiles.com/underconstruction/HoHotSpringsBath9452ssunder_construction_fire.gif) ![](http://www.textfiles.com/underconstruction/yoyosemitegorge3116Constructionbarmove33.gif)

![](http://www.textfiles.com/underconstruction/ColosseumStadium8141cuteconstruct.gif)

![](http://www.textfiles.com/underconstruction/HoHollywoodAgency7728construct4.gif) ![](http://www.textfiles.com/underconstruction/HeHeartlandGarden5828constructionuc3.gif) ![](http://www.textfiles.com/underconstruction/HoHollywoodChateau4647imagesunderconstruction.gif) ![](http://www.textfiles.com/underconstruction/CoColosseumPressbox6848picsconstruction.gif)

![](http://www.textfiles.com/underconstruction/EnEnchantedForestFountain4640underconunderconstruction2.gif)

![](http://www.textfiles.com/underconstruction/ththe300exhavenunderconstruction.gif)

![](http://www.textfiles.com/underconstruction/CaCapeCanaveralHall8606gifsunderconstruction.gif)

# check-it

[![Build Status](https://travis-ci.org/DalekBaldwin/check-it.svg?branch=master)](https://travis-ci.org/DalekBaldwin/check-it)

## Value Generation

Generators are constructed using the `generator` macro. It takes a generator type spec as a single argument. Values are then generated by calling `generate` on a generator object.

The `integer` generator accepts the same syntax as the standard compound type specifier syntax for integers:

```lisp
;; generates any integer
(integer)

;; also generates any integer
(integer * *)

;; generates integers greater than or equal to 5
(integer 5)

;; generates integers less than or equal to 10
(integer * 10)
```

The `real` generator works similarly.

In addition to the constraints you choose in the type specifier, the absolute values of generated numbers are also bound by the parameter `*size*`.

The `list` generator generates a list of random length consisting of values generated by its subgenerator. Its length is bounded by the parameter `*list-size*`.

```lisp
(generate (generator (list (integer))))
;; sample result: (9 -3 3 -2 3 10 6 -8 9 10)
```

The `tuple` generator generates a list containing the results of each of its subgenerators, so unlike the `list` generator, its length is fixed:

```lisp
(generate (generator (tuple (integer) (real)))
;; sample result: (-6 -4.168296)
```

The `or` generator randomly chooses one of its subgenerators and returns its result.

```lisp
(generate (generator (or (integer) (real))))
;; sample result: -1.0087109
```

The `guard` generator generates a result from its subgenerator and checks whether the result passes the guard predicate. If not, keeps generating new results until it finds a value that does.

```lisp
;; same range of values as (integer 5)
(guard (lambda (x) (>= x 5)) (integer))
```

The `struct` generator generates a struct of a given struct type with slots generated by the corresponding slot generators. So if you have a struct definition that looks like:

```lisp
(defstruct a-struct
  a-slot
  another-slot)
```

You can create a generator type spec that looks like:

```lisp
(struct a-struct :a-slot (integer) :another-slot (real))
```

On ABCL and Allegro CL I haven't found a way to construct a struct given its type name, so on these implementations you must pass the name of a constructor function as the second argument to the type spec:

```lisp
(struct a-struct make-a-struct :a-slot (integer) :another-slot (real))
```

You can define your own generator types with `defgenerator`. User-defined generator types can be recursive. Here's a useless example:

```lisp
;; same range of values as (integer)
(defgenerator recursive () `(or (integer) (recursive)))
```

With naive generation strategies, recursive generators can easily generate values of unbounded size. There are currently two ways to dampen exponential explosion.

When a user-defined generator appears as an alternative in an `or` generator, its relative probability of being chosen decreases with each recursive descent.

```lisp
(defgenerator recursive-explode () `(list (or (integer) (recursive-explode))))
```

Additionally, the maximum possible list length is reduced with every `list` generation that occurs within the dynamic scope of another `list` generation.

```lisp
(defgenerator list-explode () `(or (integer) (list (list-explode))))
```

But it's your responsibility not to write type specs that can't possibly generate anything other than unbounded values.

```lisp
(defgenerator inherently-unbounded () `(tuple (integer) (inherently-unbounded))
```

## Checking

Use the `check-it` macro to perform a test run. Here's another useless example:

```lisp
(check-it (generator (integer))
          (lambda (x) (integerp x)))
```

This will generate `*num-trials*` random values and test them against the test predicate. If a random value fails, check-it will search for values of smaller complexity until it finds the least complex value it can that fails the test while respecting the generator's type spec.

Now here's the fun part. You can configure the `check-it` macro to automatically add new deterministic regression tests to your project using the shrunken failure value when a randomized test fails:

```lisp
(check-it (generator (integer))
          (lambda (x) (integerp x))
          :gen-output-file my-test-file
          :gen-output-package :my-test-package
          :gen-output-template
          (lambda (test-form datum &optional package)
            `(deftest ,(gentemp "TEST" package) ()
               (is (funcall ,test-form ,datum)))))
```

This uses fairly naive code generation, but if you adhere to a certain workflow and follow a few simple guidelines it works fine. It is recommended that you output such tests to a special file that is initially filled only with the code you need to set up a test package and initialize a test suite in your preferred Common Lisp test framework. This file and its package should be loaded as part of your complete test system before any files and packages containing check-it tests. This way, any situation that failed a check-it test the last time you loaded your test system will fail a deterministic test the next time you load it, which should hopefully light a fire under your ass to fix already-discovered bugs before hunting for new ones.
