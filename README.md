![](http://www.textfiles.com/underconstruction/HoHotSpringsBath9452ssunder_construction_fire.gif) ![](http://www.textfiles.com/underconstruction/yoyosemitegorge3116Constructionbarmove33.gif)

![](http://www.textfiles.com/underconstruction/ColosseumStadium8141cuteconstruct.gif)

![](http://www.textfiles.com/underconstruction/HoHollywoodAgency7728construct4.gif) ![](http://www.textfiles.com/underconstruction/HeHeartlandGarden5828constructionuc3.gif) ![](http://www.textfiles.com/underconstruction/HoHollywoodChateau4647imagesunderconstruction.gif) ![](http://www.textfiles.com/underconstruction/CoColosseumPressbox6848picsconstruction.gif)

![](http://www.textfiles.com/underconstruction/EnEnchantedForestFountain4640underconunderconstruction2.gif)

![](http://www.textfiles.com/underconstruction/ththe300exhavenunderconstruction.gif)

![](http://www.textfiles.com/underconstruction/CaCapeCanaveralHall8606gifsunderconstruction.gif)

# check-it

[![Build Status](https://travis-ci.org/DalekBaldwin/check-it.svg?branch=master)](https://travis-ci.org/DalekBaldwin/check-it)

## Value Generation

Generators are constructed using the `generator` macro. It takes a generator type spec as a single argument. Values are then generated by calling `generate` on a generator object.

The `integer` generator accepts the same syntax as the standord compound type specifier syntax for integers:

```lisp
(integer) ;; generates any integer
(integer * *) ;; generates any integer
(integer 5) ;; generates integers greater than or equal to 5
(integer * 10) ;; generates integers less than or equal to 10
```

The `real` generator works similarly.

The `list` generator generates a list of random length consisting of values generated by its subgenerator.

```lisp
(generate (generator (list (integer)))) ;; (9 -3 3 -2 3 10 6 -8 9 10)
```

The `tuple` generator generates a list containing the results of each of its subgenerators, so unlike the `list` generator, its length is fixed:

```lisp
(generate (generator (tuple (integer) (real))) ;; (-6 -4.168296)
```

The `or` generator randomly chooses one of its subgenerators and returns its result.

```lisp
(generate (generator (or (integer) (real)))) ;; -1.0087109
```

The `guard` generator generates a result from its subgenerator and checks whether the result passes the guard predicate. If not, keeps generating new results until it finds a value that does.

```lisp
(guard (lambda (x) (>= x 5)) (integer)) ;; same range of values as (integer 5)
```

The `struct` generator generates a struct of a given struct type with slots generated by the corresponding slot generators. So if you have a struct definition that looks like:

```lisp
(defstruct a-struct
  a-slot
  another-slot)
```

You can create a generator type spec that looks like:

```lisp
(struct a-struct :a-slot (integer) :another-slot (real))
```

On ABCL and Allegro CL I haven't found a way to construct a struct given its type name, so on these implementations you must pass the name of a constructor function as the second argument to the type spec:

```lisp
(struct a-struct make-a-struct :a-slot (integer) :another-slot (real))
```

You can define your own generator types with `defgenerator`.

```lisp
(defgenerator abs-int (abs-min)
  `(integer ,(- abs-min) ,abs-min))
```

User-defined generator types can be recursive. Here's a useless example:

```lisp
(defgenerator recursive () `(or (integer) (recursive))) ;; same range of values as (integer)
```

With naive generation strategies, recursive generators can easily generate values of unbounded size. There are currently two ways to dampen exponential explosion.

When a user-defined generator appears as an alternative in an `or` generator, its relative probability of being chosen decreases with each recursive descent.

```lisp
(defgenerator recursive-explode () `(list (or (integer) (recursive-explode))))
```

Additionally, the maximum possible list length shrinks with every `list` generation that occurs within the dynamic scope of another `list` generation.

```lisp
(defgenerator list-explode () `(or (integer) (list (list-explode))))
```

But it's your responsibility not to write type specs that can't possibly generate anything other than unbounded values.

```lisp
(defgenerator inherently-unbounded () `(tuple (integer) (inherently-unbounded))
```

More to come...